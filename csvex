import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFColor;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.ss.util.CellRangeAddress;

import java.awt.Color;
import java.io.FileOutputStream;
import java.io.IOException;

public class ExcelStylingExample {

    public static void main(String[] args) throws IOException {

        XSSFWorkbook workbook = new XSSFWorkbook();
        XSSFSheet sheet = workbook.createSheet("Styled Sheet");

        // Create row and cell
        Row row0 = sheet.createRow(0);
        Row row1 = sheet.createRow(1);

        // Define the styles for headers
        XSSFCellStyle greenStyle = createHeaderStyle(workbook, Color.GREEN);
        XSSFCellStyle pinkStyle = createHeaderStyle(workbook, Color.PINK);
        XSSFCellStyle orangeStyle = createHeaderStyle(workbook, Color.ORANGE);
        XSSFCellStyle thickBlueBorderStyle = createThickBlueBorderStyle(workbook);

        // Pillar spans 2 rows and 2 columns
        sheet.addMergedRegion(new CellRangeAddress(0, 1, 0, 1));
        Cell pillarCell = row0.createCell(0);
        pillarCell.setCellValue("Pillar");
        pillarCell.setCellStyle(greenStyle);

        // APM spans 2 rows and 3 columns
        sheet.addMergedRegion(new CellRangeAddress(0, 1, 2, 4));
        Cell apmCell = row0.createCell(2);
        apmCell.setCellValue("APM");
        apmCell.setCellStyle(pinkStyle);

        // APPLOG spans 2 rows and 3 columns
        sheet.addMergedRegion(new CellRangeAddress(0, 1, 5, 7));
        Cell appLogCell = row0.createCell(5);
        appLogCell.setCellValue("APPLOG");
        appLogCell.setCellStyle(orangeStyle);

        // Apply thick blue borders only after specific columns
        applySelectiveBlueBorders(sheet, thickBlueBorderStyle);

        // Write output to file
        try (FileOutputStream fileOut = new FileOutputStream("styled_output.xlsx")) {
            workbook.write(fileOut);
        }
        workbook.close();
    }

    // Create header style with background color
    private static XSSFCellStyle createHeaderStyle(XSSFWorkbook workbook, Color color) {
        XSSFCellStyle style = workbook.createCellStyle();
        style.setFillForegroundColor(new XSSFColor(color, null));
        style.setFillPattern(FillPatternType.SOLID_FOREGROUND);
        style.setAlignment(HorizontalAlignment.CENTER);
        style.setVerticalAlignment(VerticalAlignment.CENTER);
        return style;
    }

    // Create thick blue border style
    private static XSSFCellStyle createThickBlueBorderStyle(XSSFWorkbook workbook) {
        XSSFCellStyle style = workbook.createCellStyle();
        style.setBorderRight(BorderStyle.THICK);
        style.setRightBorderColor(IndexedColors.BLUE.getIndex());
        return style;
    }

    // Apply selective thick blue borders after specific sections
    private static void applySelectiveBlueBorders(Sheet sheet, CellStyle thickBlueBorderStyle) {
        int[][] borderPositions = {
                {0, 1}, // After Pillar (column 1)
                {4, 4}, // After APM (column 4)
                {7, 7}  // After APPLOG (column 7)
        };

        for (int[] position : borderPositions) {
            applyBlueBorder(sheet, 0, 1, position[0], position[1], thickBlueBorderStyle);
        }
    }

    // Apply blue border to a merged region
    private static void applyBlueBorder(Sheet sheet, int firstRow, int lastRow, int firstCol, int lastCol, CellStyle borderStyle) {
        for (int row = firstRow; row <= lastRow; row++) {
            Row currentRow = sheet.getRow(row);
            for (int col = firstCol; col <= lastCol; col++) {
                Cell cell = currentRow.getCell(col);
                if (cell == null) {
                    cell = currentRow.createCell(col);
                }
                cell.setCellStyle(borderStyle);
            }
        }
    }
}

//Signalflow

import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;
import com.fasterxml.jackson.databind.*;

import java.util.*;

public class SplunkSignalFlowClient {
    private static final String SPLUNK_TOKEN = "YOUR_SPLUNK_API_TOKEN";
    private static final String REALM = "us0";

    public static void main(String[] args) throws Exception {
        String baseUrl = "https://api." + REALM + ".signalfx.com/v2/signalflow/execute";

        // Step 1: Define the SignalFlow program (7-day window)
        String signalFlowProgram = "A = data('process.thread.count', filter=filter('af.acin', '*'), start=now()-7d, stop=now())"
                + ".count(by=['af.acin','sf_service'])"
                + ".publish(label='A');";

        // Step 2: Prepare headers & payload
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("X-SF-TOKEN", SPLUNK_TOKEN);

        Map<String, Object> requestBody = new HashMap<>();
        requestBody.put("program", signalFlowProgram);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);

        // Step 3: Create RestTemplate
        RestTemplate restTemplate = new RestTemplate();

        // Step 4: Execute SignalFlow
        ResponseEntity<String> response = restTemplate.postForEntity(baseUrl, request, String.class);
        ObjectMapper mapper = new ObjectMapper();

        // Step 5: Parse sessionId from response
        JsonNode root = mapper.readTree(response.getBody());
        String channelUrl = root.get("channel").asText();
        String executionId = root.get("executionId").asText();

        System.out.println("Session started: " + executionId);

        // Step 6: Get the result from the channel
        // Will poll the SignalFlow channel URL (pseudo-real-time response stream)
        String fullChannelUrl = "https://stream." + REALM + ".signalfx.com" + channelUrl;

        HttpHeaders streamHeaders = new HttpHeaders();
        streamHeaders.set("X-SF-TOKEN", SPLUNK_TOKEN);
        HttpEntity<Void> streamRequest = new HttpEntity<>(streamHeaders);

        ResponseEntity<String> streamResponse = restTemplate.exchange(fullChannelUrl, HttpMethod.GET, streamRequest, String.class);
        String payload = streamResponse.getBody();

        // Step 7: Extract datapoints: Map<acin, Set<service>>
        Map<String, Set<String>> acinServiceMap = new HashMap<>();

        JsonNode events = mapper.readTree(payload);

        for (JsonNode event : events) {
            if (event.has("messageType") && event.get("messageType").asText().equals("data")) {
                JsonNode logicalMetricStreams = event.get("logicalMetricStreams");
                Iterator<String> keys = logicalMetricStreams.fieldNames();
                while (keys.hasNext()) {
                    String key = keys.next();
                    // key format: metric0/af.acin=value/sf_service=value
                    String[] parts = key.split("/");
                    String acin = null;
                    String service = null;
                    for (String part : parts) {
                        if (part.startsWith("af.acin=")) {
                            acin = part.split("=")[1];
                        } else if (part.startsWith("sf_service=")) {
                            service = part.split("=")[1];
                        }
                    }
                    if (acin != null && service != null) {
                        acinServiceMap.computeIfAbsent(acin, k -> new HashSet<>()).add(service);
                    }
                }
            }
        }

        // Step 8: Print map
        System.out.println("‚úÖ Onboarded components:");
        acinServiceMap.forEach((acin, services) -> {
            System.out.println("ACIN: " + acin + " => Services: " + services);
        });

        // Step 9: Stop the SignalFlow session
        String stopUrl = "https://api." + REALM + ".signalfx.com/v2/signalflow/" + executionId + "/stop";
        restTemplate.postForEntity(stopUrl, new HttpEntity<>(headers), String.class);
        System.out.println("üîö Session stopped.");
    }
}


//approach 2:
import org.springframework.http.*;
import org.springframework.web.client.RestTemplate;
import com.fasterxml.jackson.databind.*;
import java.util.*;

public class SplunkSignalFlowOneToOne {

    private static final String SPLUNK_TOKEN = "YOUR_SPLUNK_API_TOKEN";
    private static final String REALM = "us0"; // or eu0, jp1, etc.

    public static void main(String[] args) throws Exception {
        String signalFlowUrl = "https://api." + REALM + ".signalfx.com/v2/signalflow/execute";

        // 1Ô∏è‚É£ Program: Count metric streams by af.acin and sf_service over 7 days
        String program = "A = data('process.thread.count', filter=filter('af.acin', '*'), start=now()-7d, stop=now())"
                       + ".count(by=['af.acin','sf_service'])"
                       + ".publish(label='A');";

        // 2Ô∏è‚É£ HTTP setup
        HttpHeaders headers = new HttpHeaders();
        headers.set("X-SF-TOKEN", SPLUNK_TOKEN);
        headers.setContentType(MediaType.APPLICATION_JSON);

        Map<String, Object> body = new HashMap<>();
        body.put("program", program);

        HttpEntity<Map<String, Object>> request = new HttpEntity<>(body, headers);
        RestTemplate restTemplate = new RestTemplate();

        // 3Ô∏è‚É£ Start SignalFlow execution
        System.out.println("üöÄ Starting SignalFlow execution...");

        ResponseEntity<String> response = restTemplate.postForEntity(signalFlowUrl, request, String.class);
        ObjectMapper mapper = new ObjectMapper();
        JsonNode responseJson = mapper.readTree(response.getBody());

        String executionId = responseJson.get("executionId").asText();
        String channelUrl = responseJson.get("channel").asText();
        String streamUrl = "https://stream." + REALM + ".signalfx.com" + channelUrl;

        // 4Ô∏è‚É£ Poll the result channel for computed streams
        HttpHeaders streamHeaders = new HttpHeaders();
        streamHeaders.set("X-SF-TOKEN", SPLUNK_TOKEN);
        HttpEntity<Void> streamRequest = new HttpEntity<>(streamHeaders);

        ResponseEntity<String> streamResponse = restTemplate.exchange(streamUrl, HttpMethod.GET, streamRequest, String.class);
        String streamData = streamResponse.getBody();

        // 5Ô∏è‚É£ One-to-One Mapping: acin ‚Üí sf_service
        Map<String, String> acinToServiceMap = new TreeMap<>();
        Set<String> duplicates = new HashSet<>();

        JsonNode events = mapper.readTree(streamData);
        for (JsonNode event : events) {
            if ("data".equals(event.path("messageType").asText())) {
                JsonNode logicalStreams = event.path("logicalMetricStreams");
                Iterator<String> keys = logicalStreams.fieldNames();
                while (keys.hasNext()) {
                    String key = keys.next(); // Example: metric0/af.acin=billing-service/sf_service=billing-api
                    String acin = null, service = null;

                    for (String part : key.split("/")) {
                        if (part.startsWith("af.acin=")) acin = part.substring("af.acin=".length());
                        if (part.startsWith("sf_service=")) service = part.substring("sf_service=".length());
                    }

                    if (acin != null && service != null) {
                        if (!acinToServiceMap.containsKey(acin)) {
                            acinToServiceMap.put(acin, service);
                        } else if (!acinToServiceMap.get(acin).equals(service)) {
                            // Conflict detected
                            duplicates.add(acin);
                        }
                    }
                }
            }
        }

        // 6Ô∏è‚É£ Print clean mappings
        System.out.println("‚úÖ Valid ACIN ‚Üí Service Mappings:");
        acinToServiceMap.forEach((acin, service) -> {
            if (!duplicates.contains(acin)) {
                System.out.println("  ‚úî " + acin + " ‚Üí " + service);
            }
        });

        // 7Ô∏è‚É£ Alert for duplicates
        if (!duplicates.isEmpty()) {
            System.out.println("\n‚ö†Ô∏è  Duplicate conflicts found:");
            duplicates.forEach(acin -> {
                System.out.println("  ‚ùå ACIN " + acin + " mapped to multiple services!");
            });
        } else {
            System.out.println("\nüéâ All mappings valid (one-to-one).");
        }

        // 8Ô∏è‚É£ Stop the SignalFlow session
        String stopUrl = "https://api." + REALM + ".signalfx.com/v2/signalflow/" + executionId + "/stop";
        restTemplate.postForEntity(stopUrl, new HttpEntity<>(headers), String.class);
        System.out.println("\nüõë SignalFlow session stopped: " + executionId);
    }
}


